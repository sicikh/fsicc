//! Generated by `cargo codegen grammar`, do not edit by hand.

#![allow(bad_style, missing_docs, unreachable_pub)]
/// The kind of syntax node, e.g. `IDENT`, `VOID_KW`, or `EXPR`.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    DOLLAR,
    L_PAREN,
    R_PAREN,
    EQ,
    FUN_KW,
    COMMENT,
    ERROR,
    IDENT_TOKEN,
    NEWLINE,
    WHITESPACE,
    EXPR,
    FUNCTION_DECLARATION,
    IDENT,
    MODULE,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    pub fn is_keyword(self) -> bool {
        matches!(self, FUN_KW)
    }
    pub fn is_punct(self) -> bool {
        matches!(self, DOLLAR | L_PAREN | R_PAREN | EQ)
    }
    pub fn is_literal(self) -> bool {
        // matches!(self,)
        todo!()
    }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "fun" => FUN_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_contextual_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            '$' => DOLLAR,
            '(' => L_PAREN,
            ')' => R_PAREN,
            '=' => EQ,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
macro_rules ! T { [$] => { $ crate :: SyntaxKind :: DOLLAR } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [fun] => { $ crate :: SyntaxKind :: FUN_KW } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; }
